"use strict";exports.__esModule=true;exports.Validator=void 0;var _primatives=require("./primatives");class Validator{constructor(name){return{validate(variables,validation,description){return validate(name,variables,validation,description)},validateArray(variables,validation,description){return validateArray(name,variables,validation,description)}}}}exports.Validator=Validator;const findCaller=(name,depth=0)=>{let caller="";const regex=/([^(]+)@|at ([^([]+) [(|[]/igms;const matches=[...String(new Error().stack).matchAll(regex)];for(const i in matches){if(i<3+depth)continue;caller=matches[i][2]||matches[i][3];if(~caller.indexOf("new Validator"))continue;if(caller.indexOf("Function")==0)caller=caller.replace("Function",name);caller=caller.replace(/(.*)(get |set )(.*)/,"$1$3");break}return caller};const validate=(name,variables,validation,description,depth=0,index=0)=>{for(const[variable,value]of Object.entries(variables)){if(typeof value!="undefined"&&value!==null&&typeof validation!="undefined"){if(typeof validation=="string"){const species=validation;if(value&&value.species&&value.species==species)continue;if((0,_primatives.checkPrimative)(value,validation))continue;const each=depth>0?"each of ":"";const expectation=description?description:`${each}"${variable}" to be a ${species}`;const message=`${findCaller(name,depth)} expects ${expectation}`;throw new TypeError(message)}else if(Array.isArray(validation)){const species=description?"":`${validation.slice(0,validation.length-1).join(", ")} or ${validation[validation.length-1]}`;let passed=false;for(const species of validation){if(value&&value.species&&value.species==species){passed=true;break}else if((0,_primatives.checkPrimative)(value,species)){passed=true;break}}if(!passed){const each=depth>0?"each of ":"";const expectation=description?description:`${each}"${variable}" to be a ${species}`;const message=`${findCaller(name,depth)} expects ${expectation}`;throw new TypeError(message)}}else if(typeof validation=="function"){if(!validation(value,index)){const each=depth>0?"each of ":"";const expectation=description?description:`${each}"${variable}" to be a valid value`;const message=`${findCaller(name,depth+1)} expects ${expectation}`;throw new TypeError(message)}}}else{const each=depth>0?"each of ":"";const expectation=description?description:`${each}"${variable}" to be a valid value`;const message=`${findCaller(name,depth)} expects ${expectation}`;throw new TypeError(message)}}};const validateArray=(name,variables,validation,description)=>{for(const[variable,value]of Object.entries(variables)){if(Array.isArray(value)){for(const i in value){validate(name,{[variable]:value[i]},validation,description,1,Number(i))}continue}else{validate(name,{[variable]:value},validation,description,1)}}};
//# sourceMappingURL=validator.js.map