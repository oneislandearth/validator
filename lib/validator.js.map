{"version":3,"sources":["../src/validator.js"],"names":["Validator","constructor","name","validate","variables","validation","description","validateArray","findCaller","depth","caller","regex","matches","String","Error","stack","matchAll","i","indexOf","replace","index","variable","value","Object","entries","species","each","expectation","message","TypeError","Array","isArray","slice","length","join","passed","Number"],"mappings":"8DACA,wCAGO,KAAMA,CAAAA,SAAU,CAGrBC,WAAW,CAACC,IAAD,CAAO,CAGhB,MAAO,CAGLC,QAAQ,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,WAAxB,CAAqC,CAG3C,MAAOH,CAAAA,QAAQ,CAACD,IAAD,CAAOE,SAAP,CAAkBC,UAAlB,CAA8BC,WAA9B,CAChB,CAPI,CAULC,aAAa,CAACH,SAAD,CAAYC,UAAZ,CAAwBC,WAAxB,CAAqC,CAGhD,MAAOC,CAAAA,aAAa,CAACL,IAAD,CAAOE,SAAP,CAAkBC,UAAlB,CAA8BC,WAA9B,CACrB,CAdI,CAgBR,CAtBoB,C,4BA2BvB,KAAME,CAAAA,UAAU,CAAG,CAACN,IAAD,CAAOO,KAAK,CAAG,CAAf,GAAqB,CAGtC,GAAIC,CAAAA,MAAM,CAAG,EAAb,CAGA,KAAMC,CAAAA,KAAK,CAAG,gCAAd,CAGA,KAAMC,CAAAA,OAAO,CAAG,CAAC,GAAGC,MAAM,CAAC,GAAIC,CAAAA,KAAJ,GAAYC,KAAb,CAAN,CAA0BC,QAA1B,CAAmCL,KAAnC,CAAJ,CAAhB,CAGA,IAAK,KAAMM,CAAAA,CAAX,GAAgBL,CAAAA,OAAhB,CAAyB,CAGvB,GAAIK,CAAC,CAAI,EAAIR,KAAb,CAAqB,SAGrBC,MAAM,CAAGE,OAAO,CAACK,CAAD,CAAP,CAAW,CAAX,GAAiBL,OAAO,CAACK,CAAD,CAAP,CAAW,CAAX,CAA1B,CAGA,GAAI,CAACP,MAAM,CAACQ,OAAP,CAAe,eAAf,CAAL,CAAsC,SAGtC,GAAIR,MAAM,CAACQ,OAAP,CAAe,UAAf,GAA8B,CAAlC,CAAqCR,MAAM,CAAGA,MAAM,CAACS,OAAP,CAAe,UAAf,CAA2BjB,IAA3B,CAAT,CAGrCQ,MAAM,CAAGA,MAAM,CAACS,OAAP,CAAe,qBAAf,CAAsC,MAAtC,CAAT,CAGA,KACD,CAED,MAAOT,CAAAA,MACR,CAlCD,CAqCA,KAAMP,CAAAA,QAAQ,CAAG,CAACD,IAAD,CAAOE,SAAP,CAAkBC,UAAlB,CAA8BC,WAA9B,CAA2CG,KAAK,CAAG,CAAnD,CAAsDW,KAAK,CAAG,CAA9D,GAAoE,CAGnF,IAAK,KAAM,CAACC,QAAD,CAAWC,KAAX,CAAX,EAAgCC,CAAAA,MAAM,CAACC,OAAP,CAAepB,SAAf,CAAhC,CAA2D,CAGzD,GAAI,MAAQkB,CAAAA,KAAR,EAAkB,WAAlB,EAAiCA,KAAK,GAAK,IAA3C,EAAmD,MAAQjB,CAAAA,UAAR,EAAuB,WAA9E,CAA2F,CAGzF,GAAI,MAAQA,CAAAA,UAAR,EAAuB,QAA3B,CAAqC,CAGnC,KAAMoB,CAAAA,OAAO,CAAGpB,UAAhB,CAGA,GAAIiB,KAAK,EAAIA,KAAK,CAACG,OAAf,EAA0BH,KAAK,CAACG,OAAN,EAAiBA,OAA/C,CAAwD,SAGxD,GAAI,+BAAeH,KAAf,CAAsBjB,UAAtB,CAAJ,CAAuC,SAGvC,KAAMqB,CAAAA,IAAI,CAAIjB,KAAK,CAAG,CAAT,CAAc,UAAd,CAA2B,EAAxC,CAGA,KAAMkB,CAAAA,WAAW,CAAIrB,WAAD,CAAgBA,WAAhB,CAA+B,GAAEoB,IAAK,IAAGL,QAAS,aAAYI,OAAQ,EAA1F,CAGA,KAAMG,CAAAA,OAAO,CAAI,GAAEpB,UAAU,CAACN,IAAD,CAAOO,KAAP,CAAc,YAAWkB,WAAY,EAAlE,CAGA,KAAM,IAAIE,CAAAA,SAAJ,CAAcD,OAAd,CAGP,CAxBD,IAwBO,IAAIE,KAAK,CAACC,OAAN,CAAc1B,UAAd,CAAJ,CAA+B,CAGpC,KAAMoB,CAAAA,OAAO,CAAInB,WAAD,CAAgB,EAAhB,CAAsB,GAAED,UAAU,CAAC2B,KAAX,CAAiB,CAAjB,CAAoB3B,UAAU,CAAC4B,MAAX,CAAoB,CAAxC,EAA2CC,IAA3C,CAAgD,IAAhD,CAAsD,OAAM7B,UAAU,CAACA,UAAU,CAAC4B,MAAX,CAAoB,CAArB,CAAwB,EAAtI,CAGA,GAAIE,CAAAA,MAAM,CAAG,KAAb,CAGA,IAAK,KAAMV,CAAAA,OAAX,GAAsBpB,CAAAA,UAAtB,CAAkC,CAGhC,GAAIiB,KAAK,EAAIA,KAAK,CAACG,OAAf,EAA0BH,KAAK,CAACG,OAAN,EAAiBA,OAA/C,CAAwD,CAGtDU,MAAM,CAAG,IAAT,CAGA,KAGD,CATD,IASO,IAAI,+BAAeb,KAAf,CAAsBG,OAAtB,CAAJ,CAAoC,CAGzCU,MAAM,CAAG,IAAT,CAGA,KACD,CACF,CAGD,GAAI,CAACA,MAAL,CAAa,CAGX,KAAMT,CAAAA,IAAI,CAAIjB,KAAK,CAAG,CAAT,CAAc,UAAd,CAA2B,EAAxC,CAGA,KAAMkB,CAAAA,WAAW,CAAIrB,WAAD,CAAgBA,WAAhB,CAA+B,GAAEoB,IAAK,IAAGL,QAAS,aAAYI,OAAQ,EAA1F,CAGA,KAAMG,CAAAA,OAAO,CAAI,GAAEpB,UAAU,CAACN,IAAD,CAAOO,KAAP,CAAc,YAAWkB,WAAY,EAAlE,CAGA,KAAM,IAAIE,CAAAA,SAAJ,CAAcD,OAAd,CACP,CAGF,CAhDM,IAgDA,IAAI,MAAQvB,CAAAA,UAAR,EAAuB,UAA3B,CAAuC,CAG5C,GAAI,CAACA,UAAU,CAACiB,KAAD,CAAQF,KAAR,CAAf,CAA+B,CAG7B,KAAMM,CAAAA,IAAI,CAAIjB,KAAK,CAAG,CAAT,CAAc,UAAd,CAA2B,EAAxC,CAGA,KAAMkB,CAAAA,WAAW,CAAIrB,WAAD,CAAgBA,WAAhB,CAA+B,GAAEoB,IAAK,IAAGL,QAAS,uBAAtE,CAGA,KAAMO,CAAAA,OAAO,CAAI,GAAEpB,UAAU,CAACN,IAAD,CAAOO,KAAK,CAAG,CAAf,CAAkB,YAAWkB,WAAY,EAAtE,CAGA,KAAM,IAAIE,CAAAA,SAAJ,CAAcD,OAAd,CACP,CACF,CAGF,CA/FD,IA+FO,CAGL,KAAMF,CAAAA,IAAI,CAAIjB,KAAK,CAAG,CAAT,CAAc,UAAd,CAA2B,EAAxC,CAGA,KAAMkB,CAAAA,WAAW,CAAIrB,WAAD,CAAgBA,WAAhB,CAA+B,GAAEoB,IAAK,IAAGL,QAAS,uBAAtE,CAGA,KAAMO,CAAAA,OAAO,CAAI,GAAEpB,UAAU,CAACN,IAAD,CAAOO,KAAP,CAAc,YAAWkB,WAAY,EAAlE,CAGA,KAAM,IAAIE,CAAAA,SAAJ,CAAcD,OAAd,CACP,CACF,CACF,CApHD,CAuHA,KAAMrB,CAAAA,aAAa,CAAG,CAACL,IAAD,CAAOE,SAAP,CAAkBC,UAAlB,CAA8BC,WAA9B,GAA8C,CAGlE,IAAK,KAAM,CAACe,QAAD,CAAWC,KAAX,CAAX,EAAgCC,CAAAA,MAAM,CAACC,OAAP,CAAepB,SAAf,CAAhC,CAA2D,CAGzD,GAAI0B,KAAK,CAACC,OAAN,CAAcT,KAAd,CAAJ,CAA0B,CAGxB,IAAK,KAAML,CAAAA,CAAX,GAAgBK,CAAAA,KAAhB,CAAuB,CAGrBnB,QAAQ,CAACD,IAAD,CAAO,CAAE,CAACmB,QAAD,EAAYC,KAAK,CAACL,CAAD,CAAnB,CAAP,CAAiCZ,UAAjC,CAA6CC,WAA7C,CAA0D,CAA1D,CAA6D8B,MAAM,CAACnB,CAAD,CAAnE,CACT,CAED,QAGD,CAZD,IAYO,CAGLd,QAAQ,CAACD,IAAD,CAAO,CAAE,CAACmB,QAAD,EAAYC,KAAd,CAAP,CAA8BjB,UAA9B,CAA0CC,WAA1C,CAAuD,CAAvD,CACT,CACF,CACF,CAxBD","sourcesContent":["// Import the required primative types\nimport { checkPrimative } from './primatives';\n\n// Create a class for validations\nexport class Validator {\n\n  // Create a validator for the class\n  constructor(name) {\n\n    // Return the validate functions\n    return { \n      \n      // Define the validation function\n      validate(variables, validation, description) {\n\n        // Return the validation function\n        return validate(name, variables, validation, description);\n      },\n\n      // Define the validation (for arrays) function\n      validateArray(variables, validation, description) {\n\n        // Return the validation function\n        return validateArray(name, variables, validation, description);\n      } \n    };\n  }\n}\n\n\n// Find the function where the error occurred\nconst findCaller = (name, depth = 0) => {\n\n  // Define the function name which called the validator\n  let caller = '';\n\n  // Define the regex for finding the name of the match\n  const regex = /([^(]+)@|at ([^([]+) [(|[]/igms;\n\n  // Find the matches\n  const matches = [...String(new Error().stack).matchAll(regex)];\n\n  // Check there is a match\n  for (const i in matches) {\n\n    // Skip to the line of code  in the error string which defines the caller\n    if (i < (3 + depth)) continue;\n\n    // Determine the caller\n    caller = matches[i][2] || matches[i][3];\n\n    // Skip if the caller is 'new Validator'\n    if (~caller.indexOf('new Validator')) continue;\n\n    // Check if the caller starts with 'Function' and replace 'Function' with the validator name\n    if (caller.indexOf('Function') == 0) caller = caller.replace('Function', name);\n\n    // Remove the 'get ' and 'set ' if there are computed properties\n    caller = caller.replace(/(.*)(get |set )(.*)/, '$1$3');\n\n    // Break the loop\n    break;\n  }\n\n  return caller;\n};\n\n// Validate each of the variables\nconst validate = (name, variables, validation, description, depth = 0, index = 0) => {\n\n  // Iterate through each variable\n  for (const [variable, value] of Object.entries(variables)) {\n\n    // Check if there is a value and a validation function\n    if (typeof (value) != 'undefined' && value !== null && typeof (validation) != 'undefined') {\n\n      // Check if the validation is a single species\n      if (typeof (validation) == 'string') {\n\n        // Define the species as the validation\n        const species = validation;\n\n        // Check the value against the species, and skip to the next value\n        if (value && value.species && value.species == species) continue;\n\n        // Check if the value is a primative type, and skip to the next value\n        if (checkPrimative(value, validation)) continue;\n\n        // Determine whether to add each of not\n        const each = (depth > 0) ? 'each of ' : '';\n\n        // Determine the expected outcome\n        const expectation = (description) ? description : `${each}\"${variable}\" to be a ${species}`; \n\n        // Determine the error message\n        const message = `${findCaller(name, depth)} expects ${expectation}`;\n\n        // Throw an error detailing the place where the error occurred\n        throw new TypeError(message);\n\n        // Check if the validation is an array of species\n      } else if (Array.isArray(validation)) {\n\n        // Define the list of species options (prevent formatting if there is a description)\n        const species = (description) ? '' : `${validation.slice(0, validation.length - 1).join(', ')} or ${validation[validation.length - 1]}`;\n\n        // Determine whether the values is one of the values\n        let passed = false;\n\n        // Check the value against each of the species\n        for (const species of validation) {\n\n          // Check the value against the species\n          if (value && value.species && value.species == species) {\n\n            // Set the passed flag to true\n            passed = true;\n\n            // Break as the value has passed\n            break;\n\n          // Check if the value is a primative type\n          } else if (checkPrimative(value, species)) {\n\n            // Set the passed flag to true\n            passed = true;\n\n            // Break as the value has passed\n            break;\n          }\n        }\n\n        // Check if species checks did not pass\n        if (!passed) {\n\n          // Determine whether to add each of not\n          const each = (depth > 0) ? 'each of ' : '';\n\n          // Determine the expected outcome\n          const expectation = (description) ? description : `${each}\"${variable}\" to be a ${species}`; \n\n          // Determine the error message\n          const message = `${findCaller(name, depth)} expects ${expectation}`;\n\n          // Throw an error detailing the place where the error occurred\n          throw new TypeError(message);\n        }\n\n        // Check if the validation is a function\n      } else if (typeof (validation) == 'function') {\n\n        // Check and run the validation function for the value\n        if (!validation(value, index)) {\n\n          // Determine whether to add each of not\n          const each = (depth > 0) ? 'each of ' : '';\n\n          // Determine the expected outcome\n          const expectation = (description) ? description : `${each}\"${variable}\" to be a valid value`; \n\n          // Determine the error message\n          const message = `${findCaller(name, depth + 1)} expects ${expectation}`;\n\n          // Throw an error detailing the place where the error occurred\n          throw new TypeError(message);\n        }\n      }\n  \n    // Catch the case where there is no value or validation type\n    } else { \n\n      // Determine whether to add each of not\n      const each = (depth > 0) ? 'each of ' : '';\n\n      // Determine the expected outcome\n      const expectation = (description) ? description : `${each}\"${variable}\" to be a valid value`; \n\n      // Determine the error message\n      const message = `${findCaller(name, depth)} expects ${expectation}`;\n\n      // Throw an error detailing the place where the error occurred\n      throw new TypeError(message);\n    }\n  }\n};\n\n// Validate all of the values in each array\nconst validateArray = (name, variables, validation, description) => {\n\n  // Iterate through each variable\n  for (const [variable, value] of Object.entries(variables)) {\n\n    // Check if the value is an array of values\n    if (Array.isArray(value)) {\n\n      // Iterate through each of the values in the value\n      for (const i in value) {\n      \n        // Validate the value\n        validate(name, { [variable]: value[i] }, validation, description, 1, Number(i));\n      }\n\n      continue;\n\n    // Handle the case where the value is not an array\n    } else {\n\n      // Validate using the standard method\n      validate(name, { [variable]: value }, validation, description, 1);\n    }\n  }\n};"],"file":"validator.js"}